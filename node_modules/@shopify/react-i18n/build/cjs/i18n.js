'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dates = require('@shopify/dates');
var name = require('@shopify/name');
var functionEnhancers = require('@shopify/function-enhancers');
var i18n = require('@shopify/i18n');
var types = require('./types.js');
var index = require('./constants/index.js');
var errors = require('./errors.js');
var translate = require('./utilities/translate.js');
var currencyDecimalPlaces = require('./constants/currency-decimal-places.js');
var identifyScripts = require('./utilities/identifyScripts.js');
var money = require('./utilities/money.js');
var string = require('./utilities/string.js');

// Used for currencies that don't use fractional units (eg. JPY)
const PERIOD = '.';
const NEGATIVE_SIGN = '-';
const REGEX_DIGITS = /\d/g;
const REGEX_NON_DIGITS = /\D/g;
const REGEX_PERIODS = /\./g;
class I18n {
  get language() {
    return i18n.languageFromLocale(this.locale);
  }
  get region() {
    return i18n.regionFromLocale(this.locale);
  }

  /**
   * @deprecated Use I18n#region instead.
   */
  get countryCode() {
    return i18n.regionFromLocale(this.locale);
  }
  get languageDirection() {
    return index.RTL_LANGUAGES.includes(this.language) ? types.LanguageDirection.Rtl : types.LanguageDirection.Ltr;
  }
  get isRtlLanguage() {
    return this.languageDirection === types.LanguageDirection.Rtl;
  }
  get isLtrLanguage() {
    return this.languageDirection === types.LanguageDirection.Ltr;
  }
  constructor(translations, {
    locale: _locale,
    currency: _currency,
    timezone,
    country,
    pseudolocalize = false,
    onError,
    loading,
    interpolate
  }) {
    this.getCurrencySymbol = (currencyCode, locale = this.locale) => {
      const currency = currencyCode || this.defaultCurrency;
      if (currency == null) {
        throw new errors.MissingCurrencyCodeError('formatCurrency cannot be called without a currency code.');
      }
      return this.getShortCurrencySymbol(currency, locale);
    };
    this.numberSymbols = functionEnhancers.memoize(() => {
      const formattedNumber = this.formatNumber(123456.7, {
        maximumFractionDigits: 1,
        minimumFractionDigits: 1
      });
      let thousandSymbol;
      let decimalSymbol;
      for (const char of formattedNumber) {
        if (isNaN(parseInt(char, 10))) {
          if (thousandSymbol) decimalSymbol = char;else thousandSymbol = char;
        }
      }
      return {
        thousandSymbol,
        decimalSymbol
      };
    });
    this.translations = translations;
    this.locale = _locale;
    this.defaultCountry = country;
    this.defaultCurrency = _currency;
    this.defaultTimezone = timezone;
    this.pseudolocalize = pseudolocalize;
    this.defaultInterpolate = interpolate;
    this.onError = onError || this.defaultOnError;
    this.loading = loading || false;
  }
  translate(id, optionsOrReplacements, replacements) {
    const {
      pseudolocalize,
      defaultInterpolate
    } = this;
    let normalizedOptions;
    const defaultOptions = {
      pseudotranslate: pseudolocalize,
      interpolate: defaultInterpolate
    };
    if (optionsOrReplacements == null) {
      normalizedOptions = defaultOptions;
    } else if (this.isTranslateOptions(optionsOrReplacements)) {
      normalizedOptions = {
        ...defaultOptions,
        ...optionsOrReplacements,
        replacements
      };
    } else {
      normalizedOptions = {
        ...defaultOptions,
        replacements: optionsOrReplacements
      };
    }
    try {
      return translate.translate(id, normalizedOptions, this.translations, this.locale);
    } catch (error) {
      this.onError(error);
      return '';
    }
  }
  getTranslationTree(id, replacements) {
    try {
      if (!replacements) {
        return translate.getTranslationTree(id, this.translations, this.locale);
      }
      return translate.getTranslationTree(id, this.translations, this.locale, replacements);
    } catch (error) {
      this.onError(error);
      return '';
    }
  }
  translationKeyExists(id, absolute = false) {
    try {
      const result = translate.getTranslationTree(id, this.translations, this.locale);
      if (absolute) return typeof result === 'string';
      return true;
    } catch (error) {
      return false;
    }
  }
  formatNumber(amount, {
    as,
    precision,
    ...options
  } = {}) {
    const {
      locale,
      defaultCurrency: currency
    } = this;
    if (as === 'currency' && currency == null && options.currency == null) {
      this.onError(new errors.MissingCurrencyCodeError(`formatNumber(amount, {as: 'currency'}) cannot be called without a currency code.`));
      return '';
    }
    return translate.memoizedNumberFormatter(locale, {
      style: as,
      maximumFractionDigits: precision,
      currency,
      ...options
    }).format(amount);
  }
  unformatNumber(input) {
    const {
      decimalSymbol
    } = this.numberSymbols();
    const normalizedValue = this.normalizedNumber(input, decimalSymbol);
    return normalizedValue === '' ? '' : parseFloat(normalizedValue).toString();
  }
  formatCurrency(amount, {
    form,
    ...options
  } = {}) {
    switch (form) {
      case 'auto':
        return this.formatCurrencyAuto(amount, options);
      case 'explicit':
        return this.formatCurrencyExplicit(amount, options);
      case 'short':
        return this.formatCurrencyShort(amount, options);
      case 'none':
        return this.formatCurrencyNone(amount, options);
      default:
        return this.formatCurrencyAuto(amount, options);
    }
  }
  unformatCurrency(input, currencyCode) {
    const {
      decimalSymbol
    } = this.numberSymbols();
    const decimalPlaces = currencyDecimalPlaces.currencyDecimalPlaces.get(currencyCode.toUpperCase());
    const normalizedValue = this.normalizedNumber(input, decimalSymbol, decimalPlaces);
    if (normalizedValue === '') {
      return '';
    }
    if (decimalPlaces === 0) {
      const roundedAmount = parseFloat(normalizedValue).toFixed(0);
      return `${roundedAmount}.${'0'.repeat(currencyDecimalPlaces.DEFAULT_DECIMAL_PLACES)}`;
    }
    return parseFloat(normalizedValue).toFixed(decimalPlaces);
  }
  formatPercentage(amount, options = {}) {
    return this.formatNumber(amount, {
      as: 'percent',
      ...options
    });
  }
  formatDate(date, options = {}) {
    const {
      locale,
      defaultTimezone
    } = this;
    const {
      timeZone = defaultTimezone
    } = options;
    const {
      style = undefined,
      ...formatOptions
    } = options || {};
    if (style) {
      switch (style) {
        case index.DateStyle.Humanize:
          return this.humanizeDate(date, {
            ...formatOptions,
            timeZone
          });
        case index.DateStyle.DateTime:
          return this.formatDateTime(date, {
            ...formatOptions,
            timeZone,
            ...index.dateStyle[style]
          });
        default:
          return this.formatDate(date, {
            ...formatOptions,
            ...index.dateStyle[style]
          });
      }
    }
    return dates.formatDate(date, locale, {
      ...formatOptions,
      timeZone
    });
  }
  ordinal(amount) {
    const {
      locale
    } = this;
    const group = translate.memoizedPluralRules(locale, {
      type: 'ordinal'
    }).select(amount);
    return this.translate(group, {
      scope: 'ordinal'
    }, {
      amount
    });
  }
  weekStartDay(argCountry) {
    const country = argCountry || this.defaultCountry;
    if (!country) {
      throw new errors.MissingCountryError('weekStartDay() cannot be called without a country code.');
    }
    return index.WEEK_START_DAYS.get(country) || index.DEFAULT_WEEK_START_DAY;
  }
  /**
   * @deprecated Replace usage of `i18n.getCurrencySymbolLocalized(locale, currency)` with `i18n.getCurrencySymbol(currency, locale)`
   */
  getCurrencySymbolLocalized(locale, currency) {
    return this.getShortCurrencySymbol(currency, locale);
  }
  formatName(firstName, lastName, options) {
    return name.formatName({
      name: {
        givenName: firstName,
        familyName: lastName
      },
      locale: this.locale,
      options
    });
  }
  abbreviateName({
    firstName,
    lastName,
    idealMaxLength = 3
  }) {
    return name.abbreviateName({
      name: {
        givenName: firstName,
        familyName: lastName
      },
      locale: this.locale,
      options: {
        idealMaxLength
      }
    });
  }
  abbreviateBusinessName({
    name: name$1,
    idealMaxLength = 3
  }) {
    return name.abbreviateBusinessName({
      name: name$1,
      idealMaxLength
    });
  }
  identifyScript(text) {
    return identifyScripts.identifyScripts(text);
  }
  hasEasternNameOrderFormatter() {
    return name.hasFamilyNameGivenNameOrdering(this.locale);
  }

  // eslint-disable-next-line @typescript-eslint/member-ordering

  formatCurrencyAuto(amount, options = {}) {
    // use the short format if we can't determine a currency match, or if the
    // currencies match, use explicit when the currencies definitively do not
    // match.
    const formatShort = options.currency == null || this.defaultCurrency == null || options.currency === this.defaultCurrency;
    return formatShort ? this.formatCurrencyShort(amount, options) : this.formatCurrencyExplicit(amount, options);
  }
  formatCurrencyExplicit(amount, options = {}) {
    const value = this.formatCurrencyShort(amount, options);
    const isoCode = options.currency || this.defaultCurrency || '';
    if (value.includes(isoCode)) {
      return value;
    }
    return `${value} ${isoCode}`;
  }
  formatCurrencyShort(amount, options = {}) {
    var _negativeRegex$exec;
    const formattedAmount = this.formatCurrencyNone(amount, options);
    const negativeRegex = new RegExp(`${index.UnicodeCharacterSet.DirectionControl}*${index.UnicodeCharacterSet.Negative}`, 'g');
    const negativeMatch = ((_negativeRegex$exec = negativeRegex.exec(formattedAmount)) === null || _negativeRegex$exec === void 0 ? void 0 : _negativeRegex$exec.shift()) || '';
    const shortSymbol = this.getShortCurrencySymbol(options.currency);
    const formattedWithSymbol = shortSymbol.prefixed ? `${shortSymbol.symbol}${formattedAmount}` : `${formattedAmount}${shortSymbol.symbol}`;
    return `${negativeMatch}${formattedWithSymbol.replace(negativeMatch, '')}`;
  }
  formatCurrencyNone(amount, options = {}) {
    const {
      locale
    } = this;
    let adjustedPrecision = options.precision;
    if (adjustedPrecision === undefined) {
      const currency = options.currency || this.defaultCurrency || '';
      adjustedPrecision = currencyDecimalPlaces.currencyDecimalPlaces.get(currency.toUpperCase());
    }
    return translate.memoizedNumberFormatter(locale, {
      style: 'decimal',
      minimumFractionDigits: adjustedPrecision,
      maximumFractionDigits: adjustedPrecision,
      ...options
    }).format(amount);
  }

  // Intl.NumberFormat sometimes annotates the "currency symbol" with a country code.
  // For example, in locale 'fr-FR', 'USD' is given the "symbol" of " $US".
  // This method strips out the country-code annotation, if there is one.
  // (So, for 'fr-FR' and 'USD', the return value would be " $").
  //
  // For other currencies, e.g. CHF and OMR, the "symbol" is the ISO currency code.
  // In those cases, we return the full currency code without stripping the country.
  getShortCurrencySymbol(currency = this.defaultCurrency || '', locale = this.locale) {
    const regionCode = currency.substring(0, 2);
    let shortSymbolResult;

    // currencyDisplay: 'narrowSymbol' was added to iOS in v14.5. See https://caniuse.com/?search=currencydisplay
    // We still support ios 12/13, so we need to check if this works and fallback to the default if not
    // All other supported browsers understand narrowSymbol, so once our minimum iOS version is updated we can remove this fallback
    try {
      shortSymbolResult = money.getCurrencySymbol(locale, {
        currency,
        currencyDisplay: 'narrowSymbol'
      });
    } catch {
      shortSymbolResult = money.getCurrencySymbol(locale, {
        currency
      });
    }
    if (currency in index.CurrencyShortFormException) {
      return {
        symbol: index.CurrencyShortFormException[currency],
        prefixed: shortSymbolResult.prefixed
      };
    }
    const shortSymbol = shortSymbolResult.symbol.replace(regionCode, '');
    const alphabeticCharacters = /[A-Za-zÀ-ÖØ-öø-ÿĀ-ɏḂ-ỳ]/;
    return alphabeticCharacters.exec(shortSymbol) ? shortSymbolResult : {
      symbol: shortSymbol,
      prefixed: shortSymbolResult.prefixed
    };
  }
  humanizeDate(date, options) {
    return dates.isFutureDate(date) ? this.humanizeFutureDate(date, options) : this.humanizePastDate(date, options);
  }
  formatDateTime(date, options) {
    const {
      defaultTimezone
    } = this;
    const {
      timeZone = defaultTimezone
    } = options;
    return this.translate('date.humanize.lessThanOneYearAway', {
      date: this.getDateFromDate(date, {
        ...options,
        timeZone
      }),
      time: this.getTimeFromDate(date, {
        ...options,
        timeZone
      })
    });
  }
  humanizePastDate(date, options) {
    if (dates.isLessThanOneMinuteAgo(date)) {
      return this.translate('date.humanize.lessThanOneMinuteAgo');
    }
    if (dates.isLessThanOneHourAgo(date)) {
      const now = new Date();
      const minutes = Math.floor((now.getTime() - date.getTime()) / dates.TimeUnit.Minute);
      return this.translate('date.humanize.lessThanOneHourAgo', {
        count: minutes
      });
    }
    const timeZone = options === null || options === void 0 ? void 0 : options.timeZone;
    const time = this.getTimeFromDate(date, options);
    if (dates.isToday(date, timeZone)) {
      return time;
    }
    if (dates.isYesterday(date, timeZone)) {
      return this.translate('date.humanize.yesterday', {
        time
      });
    }
    if (dates.isLessThanOneWeekAgo(date)) {
      const weekday = this.getWeekdayFromDate(date, options);
      return this.translate('date.humanize.lessThanOneWeekAgo', {
        weekday,
        time
      });
    }
    if (dates.isLessThanOneYearAgo(date)) {
      const monthDay = this.getMonthDayFromDate(date, options);
      return this.translate('date.humanize.lessThanOneYearAgo', {
        date: monthDay,
        time
      });
    }
    return this.formatDate(date, {
      ...options,
      style: index.DateStyle.Short
    });
  }
  humanizeFutureDate(date, options) {
    const timeZone = options === null || options === void 0 ? void 0 : options.timeZone;
    const time = this.getTimeFromDate(date, options);
    if (dates.isToday(date, timeZone)) {
      return this.translate('date.humanize.today', {
        time
      });
    }
    if (dates.isTomorrow(date, timeZone)) {
      return this.translate('date.humanize.tomorrow', {
        time
      });
    }
    if (dates.isLessThanOneWeekAway(date)) {
      const weekday = this.getWeekdayFromDate(date, options);
      return this.translate('date.humanize.lessThanOneWeekAway', {
        weekday,
        time
      });
    }
    if (dates.isLessThanOneYearAway(date)) {
      const monthDay = this.getMonthDayFromDate(date, options);
      return this.translate('date.humanize.lessThanOneYearAway', {
        date: monthDay,
        time
      });
    }
    return this.formatDate(date, {
      ...options,
      style: index.DateStyle.Short
    });
  }
  getTimeZone(date, options) {
    const {
      localeMatcher,
      formatMatcher,
      timeZone
    } = options || {};
    const hourZone = this.formatDate(date, {
      localeMatcher,
      formatMatcher,
      timeZone,
      hour12: false,
      timeZoneName: 'short',
      hour: 'numeric'
    });
    const zoneMatchGroup = /\s([\w()+\-:.]+$)/.exec(hourZone);
    return zoneMatchGroup ? zoneMatchGroup[1] : '';
  }
  getDateFromDate(date, options) {
    const {
      localeMatcher,
      formatMatcher,
      weekday,
      day,
      month,
      year,
      era,
      timeZone,
      timeZoneName
    } = options || {};
    const formattedDate = this.formatDate(date, {
      localeMatcher,
      formatMatcher,
      weekday,
      day,
      month,
      year,
      era,
      timeZone,
      timeZoneName: timeZoneName === 'short' ? undefined : timeZoneName
    });
    return formattedDate;
  }
  getTimeFromDate(date, options) {
    const {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone,
      timeZoneName
    } = options || {};
    const formattedTime = this.formatDate(date, {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone,
      timeZoneName: timeZoneName === 'short' ? undefined : timeZoneName,
      hour: 'numeric',
      minute: '2-digit'
    }).toLocaleLowerCase();
    const time = timeZoneName === 'short' ? `${formattedTime} ${this.getTimeZone(date, options)}` : formattedTime;
    return string.convertFirstSpaceToNonBreakingSpace(time);
  }
  getWeekdayFromDate(date, options) {
    const {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone
    } = options || {};
    return this.formatDate(date, {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone,
      weekday: 'long'
    });
  }
  getMonthDayFromDate(date, options) {
    const {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone
    } = options || {};
    return this.formatDate(date, {
      localeMatcher,
      formatMatcher,
      hour12,
      timeZone,
      month: 'short',
      day: 'numeric'
    });
  }
  normalizedNumber(input, decimalSymbol, decimalPlaces = currencyDecimalPlaces.DEFAULT_DECIMAL_PLACES) {
    const maximumDecimalPlaces = Math.max(decimalPlaces, currencyDecimalPlaces.DEFAULT_DECIMAL_PLACES);
    const lastIndexOfPeriod = input.lastIndexOf(PERIOD);
    let lastIndexOfDecimal = input.lastIndexOf(decimalSymbol);

    // For locales that do not use period as the decimal symbol, users may still input a period
    // and expect it to be treated as the decimal symbol for their locale.
    if (decimalSymbol !== PERIOD && (input.match(REGEX_PERIODS) || []).length === 1 && this.decimalValue(input, lastIndexOfPeriod).length <= maximumDecimalPlaces) {
      lastIndexOfDecimal = lastIndexOfPeriod;
    }
    const integerValue = this.integerValue(input, lastIndexOfDecimal);
    const decimalValue = this.decimalValue(input, lastIndexOfDecimal);
    const negativeRegex = new RegExp(`^(${index.UnicodeCharacterSet.DirectionControl}|\\s)*${index.UnicodeCharacterSet.Negative}`, 'u');
    const negativeSign = input.match(negativeRegex) ? NEGATIVE_SIGN : '';
    const normalizedDecimal = lastIndexOfDecimal === -1 ? '' : PERIOD;
    const normalizedValue = `${negativeSign}${integerValue}${normalizedDecimal}${decimalValue}`;
    return normalizedValue.match(REGEX_DIGITS) ? normalizedValue : '';
  }
  integerValue(input, lastIndexOfDecimal) {
    return input.substring(0, lastIndexOfDecimal).replace(REGEX_NON_DIGITS, '');
  }
  decimalValue(input, lastIndexOfDecimal) {
    return input.substring(lastIndexOfDecimal + 1).replace(REGEX_NON_DIGITS, '');
  }
  isTranslateOptions(object) {
    return 'scope' in object;
  }
  defaultOnError(error) {
    throw error;
  }
}

exports.I18n = I18n;
